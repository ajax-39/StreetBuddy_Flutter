import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:street_buddy/models/place.dart';
import 'package:street_buddy/models/rating.dart';
import 'package:street_buddy/models/review.dart';
import 'package:flutter/material.dart';

/// Service responsible for handling review-related operations with Supabase
class ReviewService {
  final SupabaseClient _supabase;

  /// Creates a ReviewService instance with an optional Supabase client
  ReviewService({SupabaseClient? supabase})
      : _supabase = supabase ?? Supabase.instance.client;

  /// Toggles a like on a review for the specified user
  Future<void> toggleLike(String reviewId, String userId) async {
    final review =
        await _supabase.from('reviews').select().eq('id', reviewId).single();

    List<String> likes = List<String>.from(review['likes'] ?? []);

    // Add or remove the user ID from likes array
    if (likes.contains(userId)) {
      likes.remove(userId);
    } else {
      likes.add(userId);
    }

    await _supabase.from('reviews').update({'likes': likes}).eq('id', reviewId);
  }

  /// Updates the custom rating for a place (checks both places and explore_places tables)
  Future<void> updatePlaceCustomRating(String placeId, double rating) async {
    try {
      // Try updating in places table first
      final placesResult = await _supabase
          .from('places')
          .update({'custom_rating': rating})
          .eq('id', placeId)
          .select();

      // If no rows affected in places table, try explore_places table
      if (placesResult.isEmpty) {
        await _supabase
            .from('explore_places')
            .update({'custom_rating': rating}).eq('id', placeId);
      }
    } catch (e) {
      debugPrint('Error updating place custom rating: $e');
      // Don't throw - rating update is optional
    }
  }

  /// Returns a real-time stream of reviews for a specified place
  Stream<List<ReviewModel>> getPlaceReviews(String placeId) {
    return _supabase
        .from('reviews')
        .stream(primaryKey: ['id'])
        .eq('place_id', placeId)
        .order('created_at', ascending: false)
        .map((list) => list
            .map((doc) =>
                ReviewModel.fromMap(doc['id'], Map<String, dynamic>.from(doc)))
            .toList());
  }

  /// Adds a new review for a place
  Future<void> addReview({
    required String placeId,
    required String userId,
    required PlaceModel place,
    List<PlaceEmoji>? emojis,
    String? text,
    int? rating,
    String? safety,
    String? cost,
    List<String>? mediaUrls,
  }) async {
    try {
      // Create the review model
      final review = ReviewModel(
        id: '', // Will be generated by Supabase
        placeId: placeId,
        userId: userId,
        emojis: emojis,
        text: text,
        rating: rating,
        safety: safety,
        cost: cost,
        mediaUrls: mediaUrls ?? [],
        createdAt: DateTime.now(),
      );

      // Prepare review data for insertion
      final reviewMap = review.toMap();
      reviewMap['created_at'] =
          review.createdAt.toIso8601String(); // Insert review and get response
      final response =
          await _supabase.from('reviews').insert(reviewMap).select().single();

      final reviewId = response['id'] as String;

      // Note: No longer checking/creating place records as foreign key constraint is removed
      // Reviews can exist independently, referencing places from either 'places' or 'explore_places' tables

      // Update user's review data
      final userData = await _supabase
          .from('users')
          .select('review_ids, reviewed_places')
          .eq('uid', userId)
          .maybeSingle();

      if (userData != null) {
        // Update user's review lists
        List<String> reviewIds =
            List<String>.from(userData['review_ids'] ?? []);
        reviewIds.add(reviewId);

        Map<String, dynamic> reviewedPlaces =
            Map<String, dynamic>.from(userData['reviewed_places'] ?? {});
        reviewedPlaces[placeId] = DateTime.now().toIso8601String();

        await _supabase.from('users').update({
          'review_ids': reviewIds,
          'reviewed_places': reviewedPlaces
        }).eq('uid', userId);
      }
    } catch (e) {
      debugPrint('Error in addReview: $e');
      throw e;
    }
  }

  /// Deletes a review and updates related user data
  Future<void> deleteReview({
    required String reviewId,
    required String placeId,
    required String userId,
    required List<PlaceEmoji>? emojis,
  }) async {
    try {
      // Delete the review
      await _supabase.from('reviews').delete().eq('id', reviewId);

      // Update user's review lists
      final userData = await _supabase
          .from('users')
          .select('review_ids, reviewed_places')
          .eq('uid', userId)
          .maybeSingle();

      if (userData != null) {
        List<String> userReviewIds =
            List<String>.from(userData['review_ids'] ?? []);
        userReviewIds.remove(reviewId);

        Map<String, dynamic> reviewedPlaces =
            Map<String, dynamic>.from(userData['reviewed_places'] ?? {});
        reviewedPlaces.remove(placeId);

        await _supabase.from('users').update({
          'review_ids': userReviewIds,
          'reviewed_places': reviewedPlaces
        }).eq('uid', userId);
      }
    } catch (e) {
      debugPrint('Error in deleteReview: $e');
      throw e;
    }
  }
}
